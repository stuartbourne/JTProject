--- coder.pt	2016-02-01 19:31:53.985718682 -0500
+++ /cas/student/cisc458t/Zdrive/cisc458/phase4/ptsrc/coderlinux/coder.pt	2016-04-04 02:25:10.525081745 -0400
@@ -51,9 +51,6 @@
 
     const
 
-{ ===== Pasted contents of coder.def, generated by S/SL from coder.ssl -
-	defines Semantic Operations, Input/Output Tokens, Error Codes and Semantic Types }
-
 	{ Semantic Operations }
 	oTempAllocate = 14;
 	oTempFree = 15;
@@ -61,77 +58,76 @@
 	oOperandChooseMode = 17; { >>16 }
 	oOperandPushVariable = 18;
 	oOperandPushInteger = 19;
-	oOperandPushChar = 20;
-	oOperandPushBoolean = 21;
-	oOperandPushJumpCondition = 22; { (15) }
-	oOperandChooseJumpCondition = 23; { >>15 }
-	oOperandPushStringDescriptor = 24;
-	oOperandPushProcedure = 25;
-	oOperandPushTrap = 26;
-	oOperandPushCaseLow = 27;
-	oOperandPushCaseHigh = 28;
-	oOperandPushArrayLowerBound = 29;
-	oOperandPushArrayUpperBound = 30;
-	oOperandPushCopy = 31;
-	oOperandPushTemp = 32;
-	oOperandSetMode = 33; { (16) }
-	oOperandSetLength = 34; { (13) }
-	oOperandSetRegnum = 35; { (13) }
-	oOperandChooseLength = 36; { >>13 }
-	oOperandSetValue = 37; { (13) }
-	oOperandChooseValue = 38; { >>13 }
-	oOperandChooseManifestValue = 39; { >>13 }
-	oOperandIsValueNegative = 40; { >>14 }
-	oOperandEnterValueFromCaseTableAddress = 41;
-	oOperandEnterValueFromCodeAddress = 42;
-	oOperandEnterValueFromStringLength = 43;
-	oOperandEnterValueFromDataAreaSize = 44;
-	oOperandCompareLeftAndRight = 45; { >>14 }
-	oOperandCompareRightAndDest = 46; { >>14 }
-	oOperandIsJumpCondition = 47; { >>14 }
-	oOperandComplementJumpCondition = 48;
-	oOperandAddManifestValues = 49;
-	oOperandSubtractManifestValues = 50;
-	oOperandMultiplyManifestValues = 51;
-	oOperandNegateManifestValue = 52;
-	oOperandCompareManifestValues = 53; { >>14 }
-	oOperandMergeShuntsWithAddress = 54;
-	oOperandMergeShunts = 55;
-	oOperandFoldManifestSubscript = 56;
-	oOperandSwap = 57;
-	oOperandSwapRightAndDest = 58;
-	oOperandSwapLeftAndDest = 59;
-	oOperandPop = 60;
-	oFixPushAddress = 61;
-	oFixPushLastAddress = 62;
-	oFixSwapAddresses = 63;
-	oFixAndFreeShuntList = 64;
-	oFixAndFreeFalseBranches = 65;
-	oFixForwardBranch = 66;
-	oFixPopAddress = 67;
-	oEmitProcLabel = 68; { (16) }
-	oEmitNone = 69; { (17) }
-	oEmitSingle = 70; { (17) }
-	oEmitDouble = 71; { (17) }
-	oEmitString = 72;
-	oEmitStringLength = 73;
-	oEmitConditionalForwardBranch = 74;
-	oEmitUnconditionalForwardBranch = 75;
-	oEmitConditionalBackwardBranch = 76;
-	oEmitUnconditionalBackwardBranch = 77;
-	oEmitSourceCoordinate = 78;
-	oEmitMergeSourceCoordinate = 79;
-	oEmitCaseMergeBranch = 80;
-	oEmitCaseBranchTable = 81;
-	oCasePush = 82;
-	oCasePop = 83;
-	oCaseEnterTCodeAddress = 84;
-	oCaseEnterVariantAddress = 85;
-	oCaseEnterMergeAddress = 86;
-	oCaseEnterAbortAddress = 87;
-	oArrayEnterLowerBound = 88;
-	oArrayEnterUpperBound = 89;
-	oOptionTestChecking = 90; { >>14 }
+	oOperandPushBoolean = 20;
+	oOperandPushJumpCondition = 21; { (15) }
+	oOperandChooseJumpCondition = 22; { >>15 }
+	oOperandPushStringDescriptor = 23;
+	oOperandPushProcedure = 24;
+	oOperandPushTrap = 25;
+	oOperandPushCaseLow = 26;
+	oOperandPushCaseHigh = 27;
+	oOperandPushArrayLowerBound = 28;
+	oOperandPushArrayUpperBound = 29;
+	oOperandPushCopy = 30;
+	oOperandPushTemp = 31;
+	oOperandSetMode = 32; { (16) }
+	oOperandSetLength = 33; { (13) }
+	oOperandSetRegnum = 34; { (13) }
+	oOperandChooseLength = 35; { >>13 }
+	oOperandSetValue = 36; { (13) }
+	oOperandChooseValue = 37; { >>13 }
+	oOperandChooseManifestValue = 38; { >>13 }
+	oOperandIsValueNegative = 39; { >>14 }
+	oOperandEnterValueFromCaseTableAddress = 40;
+	oOperandEnterValueFromCodeAddress = 41;
+	oOperandEnterValueFromStringLength = 42;
+	oOperandEnterValueFromDataAreaSize = 43;
+	oOperandCompareLeftAndRight = 44; { >>14 }
+	oOperandCompareRightAndDest = 45; { >>14 }
+	oOperandIsJumpCondition = 46; { >>14 }
+	oOperandComplementJumpCondition = 47;
+	oOperandAddManifestValues = 48;
+	oOperandSubtractManifestValues = 49;
+	oOperandMultiplyManifestValues = 50;
+	oOperandNegateManifestValue = 51;
+	oOperandCompareManifestValues = 52; { >>14 }
+	oOperandMergeShuntsWithAddress = 53;
+	oOperandMergeShunts = 54;
+	oOperandFoldManifestSubscript = 55;
+	oOperandSwap = 56;
+	oOperandSwapRightAndDest = 57;
+	oOperandSwapLeftAndDest = 58;
+	oOperandPop = 59;
+	oFixPushAddress = 60;
+	oFixPushLastAddress = 61;
+	oFixSwapAddresses = 62;
+	oFixAndFreeShuntList = 63;
+	oFixAndFreeFalseBranches = 64;
+	oFixForwardBranch = 65;
+	oFixPopAddress = 66;
+	oEmitProcLabel = 67; { (16) }
+	oEmitNone = 68; { (17) }
+	oEmitSingle = 69; { (17) }
+	oEmitDouble = 70; { (17) }
+	oEmitString = 71;
+	oEmitStringLength = 72;
+	oEmitConditionalForwardBranch = 73;
+	oEmitUnconditionalForwardBranch = 74;
+	oEmitConditionalBackwardBranch = 75;
+	oEmitUnconditionalBackwardBranch = 76;
+	oEmitSourceCoordinate = 77;
+	oEmitMergeSourceCoordinate = 78;
+	oEmitCaseMergeBranch = 79;
+	oEmitCaseBranchTable = 80;
+	oCasePush = 81;
+	oCasePop = 82;
+	oCaseEnterTCodeAddress = 83;
+	oCaseEnterVariantAddress = 84;
+	oCaseEnterMergeAddress = 85;
+	oCaseEnterAbortAddress = 86;
+	oArrayEnterLowerBound = 87;
+	oArrayEnterUpperBound = 88;
+	oOptionTestChecking = 89; { >>14 }
 
 	{ Input Tokens }
 	tMultiply = 0;
@@ -159,62 +155,64 @@
 	tVarParm = 21;
 	tFetchAddress = 22;
 	tFetchInteger = 23;
-	tFetchChar = 24;
+	tFetchString = 24;
 	tFetchBoolean = 25;
 	tAssignBegin = 26;
 	tAssignAddress = 27;
 	tAssignInteger = 28;
-	tAssignChar = 29;
+	tAssignString = 29;
 	tAssignBoolean = 30;
 	tStoreParmAddress = 31;
 	tStoreParmInteger = 32;
-	tStoreParmChar = 33;
+	tStoreParmString = 33;
 	tStoreParmBoolean = 34;
 	tSubscriptBegin = 35;
 	tSubscriptAddress = 36;
 	tSubscriptInteger = 37;
-	tSubscriptChar = 38;
+	tSubscriptString = 38;
 	tSubscriptBoolean = 39;
 	tArrayDescriptor = 40;
 	tFileDescriptor = 41;
 	tIfBegin = 42;
 	tIfEnd = 43;
 	tCaseBegin = 44;
-	tWhileBegin = 45;
-	tRepeatBegin = 46;
-	tRepeatControl = 47;
-	tCallBegin = 48;
-	tParmEnd = 49;
-	tProcedureEnd = 50;
-	tWriteBegin = 51;
-	tReadBegin = 52;
-	tTrapBegin = 53;
-	tWriteEnd = 54;
-	tReadEnd = 55;
-	tLiteralAddress = 56;
-	firstCompoundToken = 56;
-	tLiteralInteger = 57;
-	tLiteralChar = 58;
-	tLiteralBoolean = 59;
-	tLiteralString = 60;
-	tStringDescriptor = 61;
-	tSkipString = 62;
-	tIfThen = 63;
-	tIfMerge = 64;
-	tCaseSelect = 65;
-	tCaseMerge = 66;
-	tCaseEnd = 67;
-	tWhileTest = 68;
-	tWhileEnd = 69;
-	tRepeatTest = 70;
-	tSkipProc = 71;
-	tCallEnd = 72;
-	tLineNumber = 73;
-	tTrap = 74;
-	lastCompoundToken = 74;
-	tEndOfFile = 75;
-	lastInputToken = 75;
-
+	tLoopBegin = 45;
+	tLoopBreakWhen = 46;
+	tCallBegin = 47;
+	tParmEnd = 48;
+	tProcedureEnd = 49;
+	tWriteBegin = 50;
+	tReadBegin = 51;
+	tTrapBegin = 52;
+	tWriteEnd = 53;
+	tReadEnd = 54;
+	tCaseElse = 55;
+	tConcatenate = 56;
+	tSubstring = 57;
+	tLength = 58;
+	tStringEqual = 59;
+	tFunctionResult = 60;
+	tLiteralAddress = 61;
+	firstCompoundToken = 61;
+	tLiteralInteger = 62;
+	tLiteralBoolean = 63;
+	tLiteralString = 64;
+	tStringDescriptor = 65;
+	tSkipString = 66;
+	tIfThen = 67;
+	tIfMerge = 68;
+	tCaseSelect = 69;
+	tCaseMerge = 70;
+	tCaseEnd = 71;
+	tLoopTest = 72;
+	tLoopEnd = 73;
+	tSkipProc = 74;
+	tCallEnd = 75;
+	tLineNumber = 76;
+	tTrap = 77;
+	lastCompoundToken = 77;
+	tEndOfFile = 78;
+	lastInputToken = 78;
 	{ Output Tokens }
 
 	{ Input/Output Tokens }
@@ -233,6 +231,7 @@
 	two = 2;
 	four = 4;
 	eight = 8;
+	ten = 10;
 	twelve = 12;
 	regAX = 1;
 	regBX = 2;
@@ -245,7 +244,6 @@
 	trReadln = 4;
 	trWrite = 5;
 	trWriteln = 6;
-	trWriteString = 7;
 	trWriteInteger = 8;
 	trWriteChar = 9;
 	trReadInteger = 10;
@@ -255,8 +253,17 @@
 	trCaseAbort = 14;
 	trEoln = 15;
 	trEof = 16;
+	trAssignString = 101;
+	trChrString = 102;
+	trConcatenate = 103;
+	trSubstring = 104;
+	trLength = 105;
+	trStringEqual = 106;
+	trReadTring = 107;
+	trWriteString = 108;
 	byte = 1;
 	word = 2;
+	string = 3;
 	{ Type 14 }
 	no = 0;
 	yes = 1;
@@ -324,107 +331,113 @@
 	EmitProgramPrologue = 7;
 	Block = 65;
 	EmitProgramEpilogue = 58;
-	OperandPopAndFreeTemp = 3295;
-	Routine = 160;
-	Statements = 264;
-	OperandNextParameter = 249;
-	EmitMove = 4016;
-	AssignStmt = 326;
-	CallStmt = 334;
-	IfStmt = 409;
-	WhileStmt = 568;
-	RepeatStmt = 625;
-	CaseStmt = 657;
-	WriteProc = 789;
-	ReadProc = 873;
-	TrapStmt = 964;
-	OperandPushVariable = 1277;
-	OperandPushExpressionAssignPopPop = 1841;
-	OperandPushExpression = 1082;
-	OperandConvertJumpConditionToData = 3320;
-	OperandForceAddressIntoTemp = 3689;
-	OperandForceToStack = 3845;
-	OperandPushBooleanControlExpression = 462;
-	FoldIfStmt = 503;
-	OperandInfixOr = 3234;
-	OperandForceToJumpCondition = 467;
-	EmitTst = 4050;
-	SkipToEndIf = 549;
+	OperandPopAndFreeTemp = 3819;
+	Routine = 155;
+	Statements = 269;
+	OperandNextParameter = 254;
+	EmitMove = 4594;
+	OperandAssignStringPopPop = 2322;
+	AssignStmt = 325;
+	CallStmt = 333;
+	IfStmt = 408;
+	WhileStmt = 567;
+	CaseStmt = 625;
+	WriteProc = 770;
+	ReadProc = 854;
+	TrapStmt = 945;
+	OperandPushVariable = 1248;
+	OperandPushExpressionAssignPopPop = 2037;
+	OperandPushExpression = 1063;
+	OperandConvertJumpConditionToData = 3844;
+	OperandForceAddressIntoTemp = 4267;
+	OperandForceToStack = 4423;
+	OperandPushBooleanControlExpression = 461;
+	FoldIfStmt = 502;
+	OperandInfixOr = 3758;
+	OperandForceToJumpCondition = 466;
+	EmitTst = 4628;
+	SkipToEndIf = 548;
 	SkipToEndWhile = 606;
-	OperandFreeTemp = 3308;
-	CaseSelect = 685;
-	CaseVariant = 688;
-	CaseEnd = 696;
-	EmitDefaultCaseAbort = 706;
-	EmitCaseSubscriptJump = 730;
-	OperandForceIntoTemp = 3604;
-	OperandSubtractRightFromLeftPop = 2322;
-	WriteParameter = 804;
-	ReadParameter = 888;
-	OperandAssignIntegerPopPop = 3257;
-	EmitStringDescriptor = 1274;
-	OperandNegate = 2147;
-	OperandAddPop = 2225;
-	OperandSubtractPop = 2344;
-	OperandMultiplyPop = 2495;
-	OperandDividePop = 2641;
-	OperandModPop = 2767;
-	OperandNot = 3230;
-	OperandOrPop = 3251;
-	OperandEqualPop = 3413;
-	OperandGreaterPop = 3488;
-	OperandLessPop = 3576;
-	OperandChr = 2890;
-	OperandOrd = 2927;
-	OperandEolnFunction = 2951;
-	OperandEofFunction = 3077;
-	OperandSubscriptIntegerPop = 1344;
-	OperandSubscriptCharPop = 1373;
-	OperandSubscriptBooleanPop = 1405;
-	OperandSubscriptNonManifestIntegerPop = 1408;
-	OperandSubscriptNonManifestCharPop = 1670;
-	OperandCheckedSubscriptNonManifestIntegerPop = 1421;
-	OperandUncheckedSubscriptNonManifestIntegerPop = 1597;
-	OperandPushArrayLowerBound = 1539;
-	OperandPushArrayUpperBound = 1555;
-	EmitCmp = 3960;
-	EmitSubscriptAbort = 1576;
-	OperandForceIntoNewTemp = 3666;
-	OperandForceAddressIntoNewTemp = 3753;
-	OperandCheckedSubscriptNonManifestCharPop = 1683;
-	OperandUncheckedSubscriptNonManifestCharPop = 1788;
-	OperandAssignCharPopPop = 3280;
-	OperandAssignBooleanPopPop = 3290;
-	OperandNegateAssignPopPop = 2122;
-	OperandAddAssignPopPopPop = 2162;
-	OperandSubtractAssignPopPopPop = 2302;
-	OperandMultiplyAssignPopPopPop = 2387;
-	OperandDivideAssignPopPopPop = 2594;
-	OperandNotAssignPopPop = 3139;
-	OperandChrAssignPopPop = 2877;
-	OperandOrdAssignPopPop = 2896;
-	OperandAddRightToLeftPop = 2195;
-	EmitAdd = 3930;
-	OperandForceLeftIntoTemp = 3652;
-	EmitSub = 3945;
-	OperandMultiplyLeftByRightPop = 2420;
-	OperandDivideLeftByRightPop = 2614;
-	SaveTempRegsToStack = 3013;
-	RestoreTempRegsFromStack = 3045;
-	OperandPushFalseTemp = 3397;
-	OperandPushTrueTemp = 3381;
-	OperandPushTempByte = 3836;
-	OperandFoldComparisonPopPop = 3580;
-	OperandPushTempWord = 3827;
-	OperandAreLeftAndRightManifest = 3872; >>14
-	OperandLeftOrRightIsTemp = 3901; >>14
+	OperandFreeTemp = 3832;
+	CaseSelect = 653;
+	CaseVariant = 656;
+	CaseEnd = 664;
+	EmitDefaultCaseAbort = 674;
+	EmitCaseSubscriptJump = 711;
+	OperandForceIntoTemp = 4199;
+	OperandSubtractRightFromLeftPop = 2716;
+	WriteParameter = 785;
+	ReadParameter = 869;
+	OperandAssignIntegerPopPop = 3781;
+	EmitStringDescriptor = 1245;
+	OperandStringEqualPop = 3937;
+	OperandNegate = 2468;
+	OperandAddPop = 2619;
+	OperandSubtractPop = 2738;
+	OperandMultiplyPop = 2889;
+	OperandDividePop = 3035;
+	OperandModPop = 3161;
+	OperandNot = 3754;
+	OperandOrPop = 3775;
+	OperandEqualPop = 4008;
+	OperandGreaterPop = 4083;
+	OperandLessPop = 4171;
+	OperandChr = 3284;
+	OperandOrd = 3378;
+	OperandEolnFunction = 3410;
+	OperandEofFunction = 3536;
+	OperandSubscriptIntegerPop = 1550;
+	OperandSubscriptStringPop = 1320;
+	OperandSubscriptBooleanPop = 1611;
+	OperandSubscriptNonManifestStringPop = 1349;
+	OperandCheckedSubscriptNonManifestStringPop = 1435;
+	OperandUncheckedSubscriptNonManifestStringPop = 1362;
+	OperandCheckedSubscriptNonManifestIntegerPop = 1627;
+	OperandPushArrayUpperBound = 1756;
+	EmitCmp = 4538;
+	OperandPushArrayLowerBound = 1742;
+	EmitSubscriptAbort = 1775;
+	OperandSubscriptNonManifestIntegerPop = 1614;
+	OperandSubscriptCharPop = 1579;
+	OperandSubscriptNonManifestCharPop = 1869;
+	OperandUncheckedSubscriptNonManifestIntegerPop = 1796;
+	OperandCheckedSubscriptNonManifestCharPop = 1882;
+	OperandUncheckedSubscriptNonManifestCharPop = 1984;
+	OperandAssignBooleanPopPop = 3814;
+	OperandLength = 3689;
+	OperandSubstringPopPop = 2483;
+	OperandConcatenatePop = 2397;
+	OperandNegateAssignPopPop = 2372;
+	OperandAddAssignPopPopPop = 2556;
+	OperandSubtractAssignPopPopPop = 2696;
+	OperandMultiplyAssignPopPopPop = 2781;
+	OperandDivideAssignPopPopPop = 2988;
+	OperandNotAssignPopPop = 3598;
+	OperandOrdAssignPopPop = 3347;
+	SaveTempRegsToStack = 3472;
+	RestoreTempRegsFromStack = 3504;
+	OperandAddRightToLeftPop = 2589;
+	EmitAdd = 4508;
+	OperandForceLeftIntoTemp = 4253;
+	EmitSub = 4523;
+	OperandMultiplyLeftByRightPop = 2814;
+	OperandDivideLeftByRightPop = 3008;
+	OperandChrAssignPopPop = 3271;
+	OperandAssignCharPopPop = 3804;
+	OperandPushFalseTemp = 3921;
+	OperandPushTrueTemp = 3905;
+	OperandPushTempByte = 4414;
+	OperandFoldComparisonPopPop = 4175;
+	OperandPushTempWord = 4405;
+	OperandForceAddressIntoNewTemp = 4331;
+	OperandAreLeftAndRightManifest = 4450; >>14
+	OperandLeftOrRightIsTemp = 4479; >>14
 	}
 
 	{ S/SL Table Parameters }
-	sslTblSize = 4085;
+	sslTblSize = 4663;
 	minSslTableValue = -32767;
 	maxSslTableValue = 32767;
-
 { ===== End of contents of coder.def }
 
 
@@ -962,12 +975,14 @@
     procedure EmitX86StringLiteral;
 	{ Emit an x86 assembly code string constant }
 	var
-	    i:	1 .. maxLiteralLength;
+	   i:	1 .. maxLiteralLength;
+	    {i:	0 .. maxLiteralLength;}
 	begin
 	    Assert ( (compoundToken = tLiteralString), assert26);
 	    write (object, '	.asciz	"');
 
 	    i := 1;
+	     {i := 0;}
 	    repeat
 		if (compoundTokenText[i] = ord('"')) or
 			(compoundTokenText[i] = ord('\')) then
@@ -1556,7 +1571,7 @@
     procedure OperandPushStringDescriptor;
 	{ Push an operand stack entry for the string descriptor }
 	begin
-	    Assert ( (compoundToken = tStringDescriptor), assert28);
+	    Assert ( (compoundToken = tLiteralString), assert28);
 	    OperandPush (mString, compoundTokenValue, undefined, word);
 	end { OperandPushStringDescriptor };
 
@@ -1850,10 +1865,18 @@
 		    read (tCode, compoundTokenValue);
 		    nextTCodeAddress := nextTCodeAddress + 1;
 
+			{writeln;
+			writeln;
+			writeln;
+			writeln;
+			write('compound token');
+			writeln;
+			write(compoundToken);}
+
 		    case compoundToken of
-			tLiteralAddress, tLiteralInteger, tLiteralChar,
-			tLiteralBoolean, tStringDescriptor, tSkipString,
-			tWhileTest, tWhileEnd, tRepeatTest, tCallEnd,
+			tLiteralAddress, tLiteralInteger,
+			tLiteralBoolean, {tStringDescriptor, tSkipString,}
+			tCallEnd, tLoopTest, tLoopEnd,
 			tLineNumber, tTrap, tIfThen, tIfMerge, tSkipProc,
 			tCaseSelect, tCaseMerge:
 			    ;	{ Do nothing }
@@ -1874,9 +1897,10 @@
 			tLiteralString:
 			    begin
 				compoundTokenLength := compoundTokenValue;
-				Assert ( (compoundTokenLength >= 1), assert5);
+				Assert ( (compoundTokenLength >= 0), assert5);
 				compoundTokenValue := tCodeAddress;
 				i := 1;
+				{ i := 0;}
 				repeat
 				    read (tCode, compoundTokenText[i]);
 				    i := i + 1;
@@ -2200,7 +2224,7 @@
 			begin
 			    lastEmittedLineNumber := undefined;
 			    OptionallyEmitSourceCoordinate;
-			    AssertTempsAreAllFree
+			    {AssertTempsAreAllFree}
 			end;
 
 		    oEmitCaseMergeBranch:
@@ -2249,12 +2273,12 @@
 				undefined, word)
 			end;
 
-		    oOperandPushChar:
+		    {oOperandPushChar:
 			begin
 			    Assert ( (compoundToken = tLiteralChar), assert19);
 			    OperandPush (mManifest, compoundTokenValue,
 				undefined, byte)
-			end;
+			end;}
 
 		    oOperandPushBoolean:
 			begin
